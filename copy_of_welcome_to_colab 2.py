# -*- coding: utf-8 -*-
"""Copy of Welcome To Colab

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1PqYGDXgKZWhhq6sTA-qNsi5ja8soE7YM
"""

from telegram.ext import ApplicationBuilder, MessageHandler, filters, CommandHandler
import re
import random
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.metrics.pairwise import cosine_similarity
import asyncio # Required for nest_asyncio and graceful shutdown
import nest_asyncio # Import nest_asyncio

# Apply nest_asyncio to allow asyncio to run inside an already running event loop.
# This resolves "RuntimeError: This event loop is already running" in environments like Colab.
nest_asyncio.apply()

TOKEN = "8208306224:AAEcvJTQRGptN0wuv3_-URXvnrrF4RT8mbY"

BOT_USERNAME = None  # Will be filled later once the bot starts and its username is known

LEARNING_MODE = False
STYLE_MEMORY = []
MAX_STYLE_MEMORY = 1000

# Corrected BOT_NAMES list - added a comma between strings to make them separate items
BOT_NAMES = [
    "Ø¬Ú©Ø³Ù†"
]

TRAINING_DATA = [
    ("Ø³Ù„Ø§Ù…", ["Ø³Ù„Ø§Ù… ", "Ø³Ù„Ø§Ù… Ú†Ø·ÙˆØ±ÛŒ ", "Ø§Ù„Ø³Ù„Ø§Ù… Ø¹Ù„ÛŒ ÛŒØ§ Ø­Ø¶Ø±Øª Ø±ÙˆØ´Ù†"]),
    ("Ø¬Ú©Ø³Ù†", ["Ù‡Ø§ ", "Ú©ÛŒØ± Ø®Ø± ", "Ø®Ø¨ Ú©ÛŒØ±","Ø¬Ø§Ù†","Ø¨Ù„Ù‡"]),
    ("Ú©Ù…Ú©", ["Ú†Ù‡ Ø±Ø® Ø¯Ø§Ø¯", "Ø±ÛŒØ¯Ù… Ú†ÛŒ Ø´Ø¯","Ø¨Ú¯Ø§ Ø±ÙØªÛŒÙ…"]),
    ("Ø¬Ú©Ø³Ù† Ø®ÙˆØ¨ÛŒØŸ", ["Ø§Ø±Ù‡ ØªÙˆ Ú†ÛŒ", "Ù…Ø±Ø³ÛŒ ØªÙˆ Ø®ÙˆØ¨ÛŒ", "Ø®ÙˆØ¨ÛŒÙˆ Ú©ÛŒØ± Ø®Ø± Ø®Ø¨ Ù†Ù‡"]),
]

def rebuild_model():
    global vectorizer, X, questions, answers

    questions = []
    answers = []

    for q, ans_list in TRAINING_DATA:
        questions.append(q)
        answers.append(ans_list)

    vectorizer = TfidfVectorizer()
    X = vectorizer.fit_transform(questions)

rebuild_model()

def is_addressed(update, context):
    text = update.message.text.lower().strip()

    if update.message.reply_to_message:
        return update.message.reply_to_message.from_user.id == context.bot.id

    if context.bot.username and context.bot.username.lower() in text:
        return True

    for name in BOT_NAMES:
        pattern = rf"^(?:[\W_]*)(?:{re.escape(name.lower())})(?:\b|[ØŒ,: ])"
        if re.search(pattern, text):
            return True

    return False

def find_best_answer(text, threshold=0.35):
    vec = vectorizer.transform([text])
    sims = cosine_similarity(vec, X)[0]

    best_idx = sims.argmax()
    if sims[best_idx] < threshold:
        return None

    return random.choice(answers[best_idx])

def valid_style_message(text):
    text = text.strip()

    if len(text.split()) < 2 or len(text.split()) > 20:
        return False

    blacklist = ["http", "@", "/", "join"]
    if any(bad in text.lower() for bad in blacklist):
        return False

    return True

def generate_style_reply():
    if not STYLE_MEMORY:
        return None
    return random.choice(STYLE_MEMORY)

async def teach_handler(update, context):
    text = update.message.text.replace("/teach", "").strip()

    if "=>" not in text:
        await update.message.reply_text(
            "ÙØ±Ù…Øª:\n/teach Ø³ÙˆØ§Ù„ => Ø¬ÙˆØ§Ø¨Û± | Ø¬ÙˆØ§Ø¨Û² | Ø¬ÙˆØ§Ø¨Û³"
        )
        return

    question, answers_text = map(str.strip, text.split("=>", 1))
    answers_list = [a.strip() for a in answers_text.split("|") if a.strip()]

    if not question or not answers_list:
        await update.message.reply_text("Ø³ÙˆØ§Ù„ ÛŒØ§ Ø¬ÙˆØ§Ø¨â€ŒÙ‡Ø§ Ù…Ø´Ú©Ù„ Ø¯Ø§Ø±Ù† ğŸ˜")
        return

    TRAINING_DATA.append((question, answers_list))
    rebuild_model()

    await update.message.reply_text("ÛŒØ§Ø¯ Ú¯Ø±ÙØªÙ…ØŒ Ø¨Ø§ Ú†Ù†Ø¯ Ø¬ÙˆØ§Ø¨ ğŸ˜‰")

async def message_handler(update, context):
    global BOT_USERNAME # Make sure to declare BOT_USERNAME as global if modifying
    global STYLE_MEMORY

    if LEARNING_MODE and not update.message.from_user.is_bot:
        msg = update.message.text

        if valid_style_message(msg):
            STYLE_MEMORY.append(msg)

            if len(STYLE_MEMORY) > MAX_STYLE_MEMORY:
                STYLE_MEMORY.pop(0)
    # Set BOT_USERNAME if it's not already set and the bot's username is available
    if BOT_USERNAME is None and context.bot.username:
        BOT_USERNAME = context.bot.username.lower()

    text = update.message.text

    if not is_addressed(update, context):
        return

    answer = find_best_answer(text)

    if answer:
        await update.message.reply_text(answer)
    else:
        await update.message.reply_text("Ø§ÛŒÙ† Ø±Ùˆ Ù‡Ù†ÙˆØ² ÛŒØ§Ø¯ Ù†Ú¯Ø±ÙØªÙ… ğŸ¤”")

async def learn_on(update, context):
    global LEARNING_MODE
    LEARNING_MODE = True
    await update.message.reply_text("ğŸ“š Ø­Ø§Ù„Øª ÛŒØ§Ø¯Ú¯ÛŒØ±ÛŒ Ù„Ø­Ù† Ø±ÙˆØ´Ù† Ø´Ø¯")

async def learn_off(update, context):
    global LEARNING_MODE
    LEARNING_MODE = False
    await update.message.reply_text("ğŸ›‘ Ø­Ø§Ù„Øª ÛŒØ§Ø¯Ú¯ÛŒØ±ÛŒ Ù„Ø­Ù† Ø®Ø§Ù…ÙˆØ´ Ø´Ø¯")

# Corrected indentation for show_samples function
async def show_samples(update, context):
    if not STYLE_MEMORY:
        await update.message.reply_text("Ú†ÛŒØ²ÛŒ ÛŒØ§Ø¯ Ù†Ú¯Ø±ÙØªÙ… Ù‡Ù†ÙˆØ²")
        return

    samples = random.sample(
        STYLE_MEMORY,
        min(5, len(STYLE_MEMORY))
    )

    text = "ğŸ§ª Ù†Ù…ÙˆÙ†Ù‡â€ŒÙ‡Ø§ÛŒ ÛŒØ§Ø¯Ú¯Ø±ÙØªÙ‡â€ŒØ´Ø¯Ù‡:\n\n"
    text += "\n".join(f"- {s}" for s in samples)

    await update.message.reply_text(text)

# Global variable to hold the running application instance.
# This allows us to stop it gracefully if the cell is re-executed.
global _telegram_app_instance
_telegram_app_instance = None # Initialize to None

# If there's an existing app instance from a previous run, try to shut it down.
# This is crucial for re-running the cell in Colab without errors.
if '_telegram_app_instance' in globals() and _telegram_app_instance is not None:
    print("Stopping existing Telegram bot application gracefully...")
    try:
        # `shutdown()` is a coroutine and needs to be awaited.
        # `asyncio.run` can be used because `nest_asyncio` allows nested event loops.
        # It will run the shutdown coroutine on the current event loop.
        asyncio.run(_telegram_app_instance.shutdown())
        print("Existing Telegram bot application stopped.")
    except Exception as e:
        print(f"Error during graceful shutdown of previous application: {e}")
    finally:
        _telegram_app_instance = None # Reset the instance after attempting shutdown

# Build the new application
app = ApplicationBuilder().token(TOKEN).build()
app.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, message_handler))
app.add_handler(CommandHandler("teach", teach_handler)) # Added handler for /teach command

# ***FIX START: Moved handler registrations for 'learn_on' and 'learn_off' before app.run_polling()***
app.add_handler(CommandHandler("learn_on", learn_on))
app.add_handler(CommandHandler("learn_off", learn_off))
# ***FIX END***

# Store the current app instance globally for future graceful shutdowns
_telegram_app_instance = app

print("Starting new Telegram bot application...")
# `run_polling` starts the bot. `close_loop=False` is important for Colab
# to prevent the bot from trying to close the main event loop.
app.add_handler(CommandHandler("learn_samples", show_samples))
app.run_polling(close_loop=False)